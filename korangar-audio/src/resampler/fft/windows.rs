use realfft::num_traits::{Float, FloatConst};

use super::sample::Sample;

/// Helper function. Standard Kaiser window with beta 10.
/// The window created is periodic.
pub(crate) fn make_window_kaiser<T: Sample>(npoints: usize) -> Vec<T> {
    KaiserWindowIter::<f64>::new(npoints, 10.0).map(|v| T::coerce(v)).collect()
}

/// Calculate a suitable relative cutoff frequency for the given sinc length
/// for the Kaiser windows function with beta 10. The result is based on an
/// approximation, which gives good results for sinc lengths from 32 to 2048.
pub(crate) fn calculate_cutoff_kaiser<T: Sample>(npoints: usize) -> T {
    // Coefficient values generated by cutoff_fit_cubic.py
    let k1 = T::coerce(6.455836318286847);
    let k2 = T::coerce(39.20747326791276);
    let k3 = T::coerce(437.0957794994604);
    let one = T::one();
    let npoints_t = T::coerce(npoints);
    one / (k1 / npoints_t + k2 / (npoints_t * npoints_t) + k3 / (npoints_t * npoints_t * npoints_t) + one)
}

/// A struct for generating Kaiser windows.
pub(crate) struct KaiserWindowIter<T> {
    /// Length of the window to generate.
    length: usize,
    /// Current iteration index.
    index: usize,
    /// Constant, meaning varies depending on window family.
    const_a: T,
    /// Constant, meaning varies depending on window family.
    const_b: T,
}

impl<T> Iterator for KaiserWindowIter<T>
where
    T: Float + FloatConst,
{
    type Item = T;

    #[inline]
    fn next(&mut self) -> Option<T> {
        if self.index == self.length {
            return None;
        }
        let val = self.calc_at_index();
        self.index += 1;
        Some(val)
    }

    #[inline]
    fn size_hint(&self) -> (usize, Option<usize>) {
        let remaining = self.length - self.index;
        (remaining, Some(remaining))
    }
}

impl<T> ExactSizeIterator for KaiserWindowIter<T>
where
    T: Float + FloatConst,
{
    #[inline]
    fn len(&self) -> usize {
        self.length
    }
}

impl<T> KaiserWindowIter<T>
where
    T: Float + FloatConst,
{
    pub(crate) fn new(length: usize, beta: f32) -> Self {
        let len_float = T::from(length).unwrap();
        let const_b = len_float / T::from(2).unwrap();
        KaiserWindowIter {
            const_a: T::from(beta).unwrap(),
            const_b,
            index: 0,
            length,
        }
    }

    fn calc_at_index(&self) -> T {
        let x_float = T::from(self.index).unwrap();
        bessel_i0(self.const_a * T::sqrt(T::one() - (x_float / self.const_b - T::one()).powi(2))) / bessel_i0(self.const_a)
    }
}

/// Simple implementation of the modified Bessel function of order 0.
fn bessel_i0<T: Float>(x: T) -> T {
    let base = x * x / T::from(4).unwrap();
    let mut term = T::one();
    let mut result = T::one();
    for idx in 1..1000 {
        term = term * base / T::from(idx * idx).unwrap();
        let previous = result;
        result = result + term;
        if result == previous {
            break;
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use std::fmt::Debug;

    use approx::assert_abs_diff_eq;
    use realfft::num_traits::{Float, FloatConst};

    use super::{KaiserWindowIter, bessel_i0, calculate_cutoff_kaiser};

    #[test]
    fn test_cutoff() {
        let cutoff = calculate_cutoff_kaiser::<f64>(128);
        assert_abs_diff_eq!(cutoff, 0.9496336360411505, epsilon = 0.001);
        let cutoff = calculate_cutoff_kaiser::<f64>(256);
        assert_abs_diff_eq!(cutoff, 0.9748085850575283, epsilon = 0.001);
    }

    #[test]
    fn test_kaiser_odd() {
        // reference: scipy.signal.windows.kaiser(13, 4.0, sym=True)
        let expected = vec![
            0.08848052607644988,
            0.23451458444645476,
            0.42541136047056394,
            0.6334317797559347,
            0.8216091340006108,
            0.9528950441054435,
            1.0,
            0.9528950441054435,
            0.8216091340006108,
            0.6334317797559347,
            0.42541136047056394,
            0.23451458444645476,
            0.08848052607644988,
        ];
        check_window_kaiser(&expected, 4.0);
    }

    #[test]
    fn test_kaiser_even() {
        // reference: scipy.signal.windows.kaiser(14, 4.0, sym=True)
        let expected = vec![
            0.08848052607644988,
            0.22142542587610076,
            0.39408799858012694,
            0.5857681621222717,
            0.7681541362093118,
            0.9111914713309941,
            0.9898205072696717,
            0.9898205072696717,
            0.9111914713309941,
            0.7681541362093118,
            0.5857681621222717,
            0.39408799858012694,
            0.22142542587610076,
            0.08848052607644988,
        ];
        check_window_kaiser(&expected, 4.0);
    }

    #[test]
    fn test_bessel_i0_f64() {
        // reference: scipy.special.i0()
        assert_approx_f64(bessel_i0(0.0), 1.0);
        assert_approx_f64(bessel_i0(1.0), 1.2660658777520082);
        assert_approx_f64(bessel_i0(2.0), 2.279585302336067);
        assert_approx_f64(bessel_i0(3.0), 4.880792585865024);
        assert_approx_f64(bessel_i0(5.0), 27.239871823604442);
        assert_approx_f64(bessel_i0(10.0), 2815.716628466254);
        assert_approx_f64(bessel_i0(30.0), 781672297823.9775);
        assert_approx_f64(bessel_i0(-1.0), 1.2660658777520082);
        assert_approx_f64(bessel_i0(-2.0), 2.279585302336067);
        assert_approx_f64(bessel_i0(-3.0), 4.880792585865024);
        assert_approx_f64(bessel_i0(-5.0), 27.239871823604442);
        assert_approx_f64(bessel_i0(-10.0), 2815.716628466254);
        assert_approx_f64(bessel_i0(-30.0), 781672297823.9775);
    }

    fn assert_approx_f64(actual: f64, expected: f64) {
        assert!(
            (actual / expected - 1.0).abs() < 0.000001,
            "Expected {}, got {}",
            expected,
            actual
        );
    }

    #[test]
    fn test_bessel_i0_f32() {
        // reference: scipy.special.i0()
        assert_approx_f32(bessel_i0(0.0), 1.0);
        assert_approx_f32(bessel_i0(1.0), 1.2660658);
        assert_approx_f32(bessel_i0(2.0), 2.2795854);
        assert_approx_f32(bessel_i0(3.0), 4.8807926);
        assert_approx_f32(bessel_i0(5.0), 27.239872);
        assert_approx_f32(bessel_i0(10.0), 2815.7166);
        assert_approx_f32(bessel_i0(30.0), 781672297823.9775);
        assert_approx_f32(bessel_i0(-1.0), 1.2660658);
        assert_approx_f32(bessel_i0(-2.0), 2.2795854);
        assert_approx_f32(bessel_i0(-3.0), 4.8807926);
        assert_approx_f32(bessel_i0(-5.0), 27.239872);
        assert_approx_f32(bessel_i0(-10.0), 2815.7166);
        assert_approx_f32(bessel_i0(-30.0), 781672297823.9775);
    }

    fn assert_approx_f32(actual: f32, expected: f32) {
        assert!((actual / expected - 1.0).abs() < 0.00001, "Expected {expected}, got {actual}");
    }

    fn check_window_kaiser<T: Float + FloatConst + Debug>(sym_expected: &[T], beta: f32) {
        let sym_len = sym_expected.len();
        let per_len = sym_len - 1;
        let iter_per = KaiserWindowIter::<T>::new(per_len, beta);

        for (idx, (actual, expected)) in iter_per.into_iter().zip(sym_expected).enumerate() {
            assert!(
                (actual - *expected).abs() < T::from(0.000001).unwrap(),
                "Diff at index {idx}, {actual:?} != {expected:?}",
            );
        }
    }
}
